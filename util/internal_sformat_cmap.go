// This file was automatically generated by genx.
// Any changes will be lost if this file is regenerated.
// see https://github.com/OneOfOne/genx
// cmd: genx -pkg github.com/OneOfOne/cmap -v -t KT=string,VT=*FormatResults -name sf_cmap -o stringformatcmap/sf_cmap.go
// +build !genx

package util

import (
	"context"
	"sync"

	"github.com/OneOfOne/cmap/hashers"
)

// DefaultShardCount is the default number of shards to use when New() or NewFromJSON() are called. The default is 256.
const sfDefaultShardCount = 1 << 8

// sfCMap is a concurrent safe sharded map to scale on multiple cores.
type sfCMap struct {
	shards   []*sfLMap
	keysPool sync.Pool
}

// New is an alias for NewSize(DefaultShardCount)
func sfNew() *sfCMap { return sfNewSize(sfDefaultShardCount) }

// NewSize returns a sfCMap with the specific shardSize, note that for performance reasons,
// shardCount must be a power of 2.
// Higher shardCount will improve concurrency but will consume more memory.
func sfNewSize(shardCount int) *sfCMap {
	// must be a power of 2
	if shardCount < 1 {
		shardCount = sfDefaultShardCount
	} else if shardCount&(shardCount-1) != 0 {
		panic("shardCount must be a power of 2")
	}

	cm := &sfCMap{
		shards: make([]*sfLMap, shardCount),
	}

	cm.keysPool.New = func() interface{} {
		out := make([]string, 0, sfDefaultShardCount) // good starting round

		return &out // return a ptr to avoid extra allocation on Get/Put
	}

	for i := range cm.shards {
		cm.shards[i] = sfNewsfLMapSize(shardCount)
	}

	return cm
}

// ShardForKey returns the sfLMap that may hold the specific key.
func (cm *sfCMap) ShardForKey(key string) *sfLMap {
	h := hasher(key)
	return cm.shards[h&uint32(len(cm.shards)-1)]
}

// Set is the equivalent of `map[key] = val`.
func (cm *sfCMap) Set(key string, val *FormatResults) {
	h := hasher(key)
	cm.shards[h&uint32(len(cm.shards)-1)].Set(key, val)
}

// SetIfNotExists will only assign val to key if it wasn't already set.
// Use `Update` if you need more logic.
func (cm *sfCMap) SetIfNotExists(key string, val *FormatResults) (set bool) {
	h := hasher(key)
	return cm.shards[h&uint32(len(cm.shards)-1)].SetIfNotExists(key, val)
}

// Get is the equivalent of `val := map[key]`.
func (cm *sfCMap) Get(key string) (val *FormatResults) {
	h := hasher(key)
	return cm.shards[h&uint32(len(cm.shards)-1)].Get(key)
}

// GetOK is the equivalent of `val, ok := map[key]`.
func (cm *sfCMap) GetOK(key string) (val *FormatResults, ok bool) {
	h := hasher(key)
	return cm.shards[h&uint32(len(cm.shards)-1)].GetOK(key)
}

// Has is the equivalent of `_, ok := map[key]`.
func (cm *sfCMap) Has(key string) bool {
	h := hasher(key)
	return cm.shards[h&uint32(len(cm.shards)-1)].Has(key)
}

// Delete is the equivalent of `delete(map, key)`.
func (cm *sfCMap) Delete(key string) {
	h := hasher(key)
	cm.shards[h&uint32(len(cm.shards)-1)].Delete(key)
}

// DeleteAndGet is the equivalent of `oldVal := map[key]; delete(map, key)`.
func (cm *sfCMap) DeleteAndGet(key string) *FormatResults {
	h := hasher(key)
	return cm.shards[h&uint32(len(cm.shards)-1)].DeleteAndGet(key)
}

// Update calls `fn` with the key's old value (or nil) and assign the returned value to the key.
// The shard containing the key will be locked, it is NOT safe to call other cmap funcs inside `fn`.
func (cm *sfCMap) Update(key string, fn func(oldval *FormatResults) (newval *FormatResults)) {
	h := hasher(key)
	cm.shards[h&uint32(len(cm.shards)-1)].Update(key, fn)
}

// Swap is the equivalent of `oldVal, map[key] = map[key], newVal`.
func (cm *sfCMap) Swap(key string, val *FormatResults) *FormatResults {
	h := hasher(key)
	return cm.shards[h&uint32(len(cm.shards)-1)].Swap(key, val)
}

// Keys returns a slice of all the keys of the map.
func (cm *sfCMap) Keys() []string {
	out := make([]string, 0, cm.Len())
	for _, sh := range cm.shards {
		out = sh.Keys(out)
	}
	return out
}

// ForEach loops over all the key/values in the map.
// You can break early by returning false.
// It **is** safe to modify the map while using this iterator, however it uses more memory and is slightly slower.
func (cm *sfCMap) ForEach(fn func(key string, val *FormatResults) bool) bool {
	keysP := cm.keysPool.Get().(*[]string)
	defer cm.keysPool.Put(keysP)

	for _, lm := range cm.shards {
		keys := (*keysP)[:0]
		if !lm.ForEach(keys, fn) {
			return false
		}
	}

	return false
}

// ForEachLocked loops over all the key/values in the map.
// You can break early by returning false.
// It is **NOT* safe to modify the map while using this iterator.
func (cm *sfCMap) ForEachLocked(fn func(key string, val *FormatResults) bool) bool {
	for _, lm := range cm.shards {
		if !lm.ForEachLocked(fn) {
			return false
		}
	}

	return true
}

// Len returns the length of the map.
func (cm *sfCMap) Len() int {
	ln := 0
	for _, lm := range cm.shards {
		ln += lm.Len()
	}
	return ln
}

// ShardDistribution returns the distribution of data amoung all shards.
// Useful for debugging the efficiency of a hash.
func (cm *sfCMap) ShardDistribution() []float64 {
	var (
		out = make([]float64, len(cm.shards))
		ln  = float64(cm.Len())
	)
	for i := range out {
		out[i] = float64(cm.shards[i].Len()) / ln
	}
	return out
}

// sfKV holds the key/value returned when Iter is called.
type sfKV struct {
	Key   string
	Value *FormatResults
}

// Iter returns a channel to be used in for range.
// Use `context.WithCancel` if you intend to break early or goroutines will leak.
// It **is** safe to modify the map while using this iterator, however it uses more memory and is slightly slower.
func (cm *sfCMap) Iter(ctx context.Context, buffer int) <-chan *sfKV {
	ch := make(chan *sfKV, buffer)
	go func() {
		cm.iterContext(ctx, ch, false)
		close(ch)
	}()
	return ch
}

// IterLocked returns a channel to be used in for range.
// Use `context.WithCancel` if you intend to break early or goroutines will leak and map access will deadlock.
// It is **NOT* safe to modify the map while using this iterator.
func (cm *sfCMap) IterLocked(ctx context.Context, buffer int) <-chan *sfKV {
	ch := make(chan *sfKV, buffer)
	go func() {
		cm.iterContext(ctx, ch, false)
		close(ch)
	}()
	return ch
}

// iterContext is used internally
func (cm *sfCMap) iterContext(ctx context.Context, ch chan<- *sfKV, locked bool) {
	fn := func(k string, v *FormatResults) bool {
		select {
		case <-ctx.Done():
			return false
		case ch <- &sfKV{k, v}:
			return true
		}
	}

	if locked {
		_ = cm.ForEachLocked(fn)
	} else {
		_ = cm.ForEach(fn)
	}
}

// NumShards returns the number of shards in the map.
func (cm *sfCMap) NumShards() int { return len(cm.shards) }

func hasher(key string) uint32 { return hashers.Fnv32(key) }

// sfLMap is a simple sync.RWMutex locked map.
// Used by sfCMap internally for sharding.
type sfLMap struct {
	m map[string]*FormatResults
	l *sync.RWMutex
}

// NewsfLMap returns a new sfLMap with the cap set to 0.
func sfNewsfLMap() *sfLMap {
	return sfNewsfLMapSize(0)
}

// NewsfLMapSize is the equivalent of `m := make(map[string]*FormatResults, cap)`
func sfNewsfLMapSize(cap int) *sfLMap {
	return &sfLMap{
		m: make(map[string]*FormatResults, cap),
		l: new(sync.RWMutex),
	}
}

// Set is the equivalent of `map[key] = val`.
func (lm *sfLMap) Set(key string, v *FormatResults) {
	lm.l.Lock()
	lm.m[key] = v
	lm.l.Unlock()
}

// SetIfNotExists will only assign val to key if it wasn't already set.
// Use `Update` if you need more logic.
func (lm *sfLMap) SetIfNotExists(key string, val *FormatResults) (set bool) {
	lm.l.Lock()
	if _, ok := lm.m[key]; !ok {
		lm.m[key], set = val, true
	}
	lm.l.Unlock()
	return
}

// Get is the equivalent of `val := map[key]`.
func (lm *sfLMap) Get(key string) (v *FormatResults) {
	lm.l.RLock()
	v = lm.m[key]
	lm.l.RUnlock()
	return
}

// GetOK is the equivalent of `val, ok := map[key]`.
func (lm *sfLMap) GetOK(key string) (v *FormatResults, ok bool) {
	lm.l.RLock()
	v, ok = lm.m[key]
	lm.l.RUnlock()
	return
}

// Has is the equivalent of `_, ok := map[key]`.
func (lm *sfLMap) Has(key string) (ok bool) {
	lm.l.RLock()
	_, ok = lm.m[key]
	lm.l.RUnlock()
	return
}

// Delete is the equivalent of `delete(map, key)`.
func (lm *sfLMap) Delete(key string) {
	lm.l.Lock()
	delete(lm.m, key)
	lm.l.Unlock()
}

// DeleteAndGet is the equivalent of `oldVal := map[key]; delete(map, key)`.
func (lm *sfLMap) DeleteAndGet(key string) (v *FormatResults) {
	lm.l.Lock()
	v = lm.m[key]
	delete(lm.m, key)
	lm.l.Unlock()
	return v
}

// Update calls `fn` with the key's old value (or nil) and assigns the returned value to the key.
// The shard containing the key will be locked, it is NOT safe to call other cmap funcs inside `fn`.
func (lm *sfLMap) Update(key string, fn func(oldVal *FormatResults) (newVal *FormatResults)) {
	lm.l.Lock()
	lm.m[key] = fn(lm.m[key])
	lm.l.Unlock()
}

// Swap is the equivalent of `oldVal, map[key] = map[key], newVal`.
func (lm *sfLMap) Swap(key string, newV *FormatResults) (oldV *FormatResults) {
	lm.l.Lock()
	oldV = lm.m[key]
	lm.m[key] = newV
	lm.l.Unlock()
	return
}

// ForEach loops over all the key/values in the map.
// You can break early by returning an error .
// It **is** safe to modify the map while using this iterator, however it uses more memory and is slightly slower.
func (lm *sfLMap) ForEach(keys []string, fn func(key string, val *FormatResults) bool) bool {
	lm.l.RLock()
	for key := range lm.m {
		keys = append(keys, key)
	}
	lm.l.RUnlock()

	for _, key := range keys {
		lm.l.RLock()
		val, ok := lm.m[key]
		lm.l.RUnlock()
		if !ok {
			continue
		}
		if !fn(key, val) {
			return false
		}
	}

	return true
}

// ForEachLocked loops over all the key/values in the map.
// You can break early by returning false
// It is **NOT* safe to modify the map while using this iterator.
func (lm *sfLMap) ForEachLocked(fn func(key string, val *FormatResults) bool) bool {
	lm.l.RLock()
	defer lm.l.RUnlock()

	for key, val := range lm.m {
		if !fn(key, val) {
			return false
		}
	}

	return true
}

// Len returns the length of the map.
func (lm *sfLMap) Len() (ln int) {
	lm.l.RLock()
	ln = len(lm.m)
	lm.l.RUnlock()
	return
}

// Keys appends all the keys in the map to buf and returns buf.
// buf may be nil.
func (lm *sfLMap) Keys(buf []string) []string {
	lm.l.RLock()
	if cap(buf) == 0 {
		buf = make([]string, 0, len(lm.m))
	}
	for k := range lm.m {
		buf = append(buf, k)
	}
	lm.l.RUnlock()
	return buf
}
